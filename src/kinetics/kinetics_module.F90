
module kinetics_module

!*****************************************************************************************
! This module is completely auto-generated by Configurator
!*****************************************************************************************

  USE ccpp_kinds, ONLY:  kind_phys

implicit none

private
public :: kinetics_type

! rateConst are computed at the beginning of the 
!   chemistry_box_solver time step.
!   They are not computed for internal steps of the
!   box-model time-step advancer
! rateConst will be thread-safe memory provided elsewhere.
! rate_constant_store will be an accessor to memory
! For now, it is allocated here. It is not thread safe

type kinetics_type
  private
  integer :: nReact
  integer :: nSpecies
  integer, allocatable         :: Pivot(:)
  real(kind_phys), allocatable :: rateConst(:)
  real(kind_phys), allocatable :: MBOdeJac(:)    ! ODE solver jacobian
  real(kind_phys), allocatable :: chemJac(:)     ! chemistry forcing jacobian
  real(kind_phys), allocatable :: rates(:)         ! rates of reactions
  real(kind_phys)              :: number_density   ! total number density (molecules/cm^3)
contains
  procedure, public :: init 
  procedure, public :: rateConst_update
  procedure, public :: rateConst_print
  procedure, public :: LinFactor
  procedure, public :: LinSolve
  procedure, public :: force
  procedure, public :: reaction_rates
  procedure, public :: dforce_dy
  procedure, public :: dForcedyxForce
!  procedure, private :: LinFactor
  final             :: DasEnder
end type kinetics_type

contains

  !---------------------------
  ! Compute time rate of change of each molecule (vmr) given reaction rates
  !---------------------------
  function force( this, vmr )

    use kinetics_utilities,only :  p_force

    class(kinetics_type) :: this
    real(kind_phys), intent(in)  ::  vmr(:)              ! volume mixing ratios of each component in order

    real(kind_phys)              ::  force(size(vmr))    ! rate of change of each molecule

    !force = p_force( vmr, this%rates, this%number_density, this%rateConst )
    call p_force( this%rateConst, vmr, this%number_density, force)

  end function force

  !---------------------------
  ! Calculate the rates for each chemical reaction
  !---------------------------
  function reaction_rates( this, vmr )

     use kinetics_utilities, only : reaction_rates => rxn_rates

     class(kinetics_type) :: this
     real(kind_phys), intent(in)  ::  vmr(:)              ! volume mixing ratios of each component in order
     real(kind_phys),             ::  reaction_rates(:)   ! reaction rates

     reaction_rates = rxn_rates( this%rateConst, vmr, this%number_density )

  end function reaction_rates

  function dforce_dy( this, vmr)

    use kinetics_utilities, only : p_dforce_dy=>dforce_dy
    use factor_solve_utilities, only: number_sparse_factor_elements

    class(kinetics_type) :: this
    real(kind_phys), intent(in)  ::  vmr(:)              ! volume mixing ratios of each component in order

    real(kind_phys) :: dforce_dy(number_sparse_factor_elements)   ! sensitivity of forcing to changes in each vmr

    call p_dforce_dy(dforce_dy, this%rateConst, vmr, this%number_density)

  end function dforce_dy



  !------------------------------------------------------
  ! allocate rateConst member array
  !------------------------------------------------------
  subroutine init( this, nRxt, nSpecies )
    use factor_solve_utilities, only: number_sparse_factor_elements
      
    class(kinetics_type) :: this
    integer, intent(in)  :: nRxt    ! total number of reactions
    integer, intent(in)  :: nSpecies! total number of reactions

    this%nReact = nRxt
    this%nSpecies = nSpecies


    if( .not. allocated(this%rates)) then
      allocate( this%rates(nRxt) )
    else
      write(*,*) 'rates_init: rateConst already allocated'
    endif

    if( .not. allocated(this%rateConst)) then
      allocate( this%rateConst(nRxt) )
    else
      write(*,*) 'rateConst_init: rateConst already allocated'
    endif

    if( .not. allocated(this%MBOdeJac)) then
      allocate( this%MBOdeJac(number_sparse_factor_elements) )
    else
      write(*,*) 'jacobian_init: MBOdeJac already allocated'
    endif

    if( .not. allocated(this%chemJac)) then
      allocate( this%chemJac(number_sparse_factor_elements) )
    else
      write(*,*) 'jacobian_init: chemJac already allocated'
    endif

    if( .not. allocated(this%Pivot)) then
      allocate( this%Pivot(nSpecies) )
    else
      write(*,*) 'jacobian_init: Pivot already allocated'
    endif

  end subroutine init

  !------------------------------------------------------
  ! prepare the rosenbrock ode solver matrix
  !------------------------------------------------------
  subroutine LinFactor( this, H, gam, Y, Singular, istatus )

   use kinetics_utilities, only : factored_alpha_minus_jac
   use factor_solve_utilities, only: number_sparse_factor_elements

    class(kinetics_type) :: this
    real(kind_phys), intent(inout) :: H          ! time step (seconds)
    real(kind_phys), intent(in)    :: gam        ! time step factor for specific rosenbrock method
    real(kind_phys), intent(in)    :: Y(:)       ! constituent concentration (molec/cm^3)
    logical, intent(inout)         :: Singular   ! singularity flag (T or F)
    integer, intent(inout)         :: istatus(:) ! rosenbrock status vector

    integer, parameter :: Ndec = 6, Nsng = 8
    real(kind_phys), parameter :: ONE  = 1._kind_phys
    real(kind_phys), parameter :: HALF = .5_kind_phys

    INTEGER  :: i, ising, Nconsecutive
    REAL(kind_phys) :: ghinv
    REAL(kind_phys) :: LU_factored(number_sparse_factor_elements)

   associate( Ghimj => this%MBOdeJac )

! Set the chemical entries for the Ode Jacobian
    Ghimj(:) = this%dforce_dy( Y )
    this%chemJac(:) = Ghimj(:)

   Nconsecutive = 0
   Singular = .TRUE.

   DO WHILE (Singular)
     ghinv = ONE/(H*gam)
!    Compute LU decomposition of [ghinv*I - Ghimj]
     call factored_alpha_minus_jac( LU_factored, ghinv, Ghimj )
     ising = 0;
     istatus(Ndec) = istatus(Ndec) + 1
     IF (ising == 0) THEN
!~~~>    If successful done
       Ghimj(:) = LU_factored(:)
       Singular = .FALSE.
     ELSE ! ISING .ne. 0
!~~~>    If unsuccessful half the step size; if 5 consecutive fails then return
       istatus(Nsng) = istatus(Nsng) + 1
       Nconsecutive = Nconsecutive + 1
       Singular = .TRUE.
       write(*,*) 'Warning: LU Decomposition returning ISING = ',ising
       IF (Nconsecutive <= 5) THEN ! Less than 5 consecutive failed decompositions
         H = H*HALF
       ELSE  ! More than 5 consecutive failed decompositions
         RETURN
       END IF  ! Nconsecutive
     END IF
   END DO

   end associate

  end subroutine LinFactor

  !------------------------------------------------------
  ! update rateConst
  ! Execute once for the chemistry-time-step advance
  ! Not called from the solver
  !------------------------------------------------------
  subroutine rateConst_update( this, k_rateConst, j_rateConst, number_density_air )

    class(kinetics_type) :: this
    real(kind_phys), intent(in) :: k_rateConst(:) ! externally supplied rate constants
    real(kind_phys), intent(in) :: j_rateConst(:)
    real(kind_phys), intent(in) :: number_density_air ! total number density
  
    integer :: i, size_krateConst, size_jrateConst
    
    size_krateConst=size(k_rateConst)
    size_jrateConst=size(j_rateConst)

    this%number_density=number_density_air

    associate( rateConstants => this%rateConst )
      ! Rate Constants
    
      ! Assign the k_rateConst to the beginning of the rateConstants array
      if (size_krateConst>  0) rateConstants(1:size_krateConst)=k_rateConst(1:size_krateConst)

      ! Assign the j_rateConst to the rateConstants array after the k_rateConst
      if (size_jrateConst > 0) rateConstants(size_krateConst+1:size_krateConst+size_jrateConst) = j_rateConst(1:size_jrateConst)
    
    end associate

  end subroutine rateConst_update

  subroutine rateConst_print( this )

    class(kinetics_type) :: this

    write(*,*) 'rate constants:'
    write(*,'(1p,5(1x,g0))') this%rateConst(:)

  end subroutine rateConst_print

  !---------------------------
  !  cleanup when k_rateConst type is removed
  !---------------------------
  subroutine DasEnder( this )

    type(kinetics_type) :: this

    if( allocated( this%rates ) ) then
       deallocate( this%rates )
    endif
    if( allocated( this%rateConst ) ) then
       deallocate( this%rateConst )
    endif
    if( allocated( this%MBOdeJac ) ) then
       deallocate( this%MBOdeJac )
    endif
    if( allocated( this%chemJac ) ) then
       deallocate( this%chemJac )
    endif
    if( allocated( this%Pivot ) ) then
       deallocate( this%Pivot )
    endif

  end subroutine DasEnder


  !---------------------------
  ! Compute dforce/dy = y''
  !---------------------------
  function dForcedyxForce( this, force ) result(d2Fdy2)

    use kinetics_utilities, only: dforce_dy_times_vector
    class(kinetics_type) :: this
    real(kind_phys), intent(in)::  force(:)         ! chem forcing; dy/dt

    real(kind_phys) ::  d2Fdy2(size(force))
   
    call dforce_dy_times_vector( this%chemJac, force, d2Fdy2 )

  end function dForcedyxForce

    SUBROUTINE LinSolve( this, B)

      use factor_solve_utilities, only : solve
      class(kinetics_type) :: this
      REAL(kind_phys), INTENT(INOUT) :: B(:)
      REAL(kind_phys)                :: x(size(B))

      call solve ( this%MBOdeJac, x, B )

      B(:) = x(:)


    END SUBROUTINE LinSolve


end module kinetics_module
